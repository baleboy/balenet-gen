<!DOCTYPE html>
<html>
  <head>
    <title>Balenet</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inconsolata&display=swap" rel="stylesheet">
    <script src="https://kit.fontawesome.com/425a6b9b56.js" crossorigin="anonymous"></script>
    <link rel="stylesheet" type="text/css" href="/style.css">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  </head>
  <body>
    <div class="page-shell">
      <div class="social-icons">
        <a href="https://linkedin.com/in/frbale"><i class="fab fa-linkedin"></i></a>
        <a href="https://github.com/baleboy"><i class="fab fa-github"></i></a>
      </div>
      <header>
        <div class="header-top">
          <div class="title-wrapper">
            <h1><a href="/">Balenet</a></h1>
          </div>
          <ul class="primary-nav">
            <li><a class="topic-label" href="/work/">Projects</a></li>
          </ul>
        </div>
      </header>
      <main>
<article>
    <h2>Managing API keys in Xcode and Github actions</h2>
    <div class="post-meta">
        <time>15 November 2025</time>
        <span class="topic-labels"><a class="topic-label" href="/topics/ai/">Ai</a> <a class="topic-label" href="/topics/programming/">Programming</a></span>
    </div>
    <div class="post-body">
        <p>Recently I started working again on my <a href="https://github.com/baleboy/hsl-widget">iOS lockscreen widget for public transports timetables</a>. I paired with Claude Code instead of ChatGPT Codex this time to see how much different it would be, and also because according to reviews it has slightly better results in coding tasks.</p><p>I can confirm that Claude Code works really well, although it is very hard to say whether it’s better than Codex or not, as the whole experience is very similar. I was a bit skeptical about using Claude for iOS development because of how tightly the workflow is integrated with XCode, but actually it is very easy to let Claude edit files side by side with Xcode, and use the latter for building and testing. Claude can use the command line Xcode build tools to check that the code builds correctly and make fixes independently, and thanks to it I have been able to add many features in a matter of a few days that would otherwise have taken me weeks. Claude even created an icon for me, although it’s butt-ugly.</p><p>In fact I’ve been so productive and are committing features so frequently, that the manual “build - test on device - publish to Testflight” (yes I have a beta user) cycle has become a bottleneck, so I decided to step into unknown territory and set up a workflow to publish new Testflight builds for every commit to main. I was a little scared at first because I’ve never done something like this for iOS, but actually thanks to Claude again I had the whole thing set up within a day, using Fastlane for building and a Github Action to run the workflow. Among other things, this enables the “couch coding” (also known as “toilet coding”) approach based on Claude Code Web that I found so exciting while updating my website, but I haven’t had the chance to try it yet.</p><p>Surprisingly however, Claude had problems fixing a relatively small thing, which is the focus of this post. To speed things up I had committed my Digitransit API key to git, which is a blatant security risk of the type that ends up on Twitter as a cautionary tale about the dangers of vibe coding. I asked Claude to fix this for both local and cloud builds, and it failed miserably. After many back and forths it was able to succeed for the local build, but it just couldn’t make it work in the Github workflow. I think part of the reason is that Claude doesn’t have access to the cloud build and therefore can’t iterate as effectively, and also that the configuration involves making changes via the XCode UI and is not as well supported by the command line. But the biggest reason might be that I just had no idea of what needed to be done and was entering pure vibe coding territory, which made me feel extremely anxious. So I resolved to do it myself and learn something in the process.</p><h2>The overall process</h2><p>The steps are actually quite simple:</p><ol><li>Create an XCode config file with the API key and keep it out of version control</li><li>Read the API key into an Info.plist variable</li><li>Read the variable from code</li><li>For the cloud build, store the API key as a repository secret and generate the Config file at build time using the store key</li></ol><p>Because the config file is not committed, the key stays in either your local machine or the Github secret.</p><p>Claude followed these steps, but after the first failures it began messing about with the config file and I felt like I was losing control. After I understood the process it was easier to direct it to more specific tasks (like how to generate the .xcconfig in Github Actions) that it could get right.</p><h2>Configuring the key in XCode</h2><p>I created the Config.xcconfig using XCode’s “File/New file from template…”:</p><img src="create-config.png" alt="Create config"/><p>I then added the config file to both Debug and Release builds for all targets:</p><img src="add-config.png" alt="Add config"/><p>Finally I added the key as an Info.plist property for both targets:</p><img src="plist-app.png" alt="App Info.plist"/><img src="plist-widget.png" alt="Widgdt Info.plist"/><p>And initialized it in the code:</p><pre><code>class HslApi {
    
    static let shared = HslApi()

    static var apiKey: String? {
        guard let apiKey = Bundle.main.object(forInfoDictionaryKey: "HSL_API_KEY") as? String else {
            fatalError("Could not read HSL API Key from Info.plist")
        }
        return apiKey
    }
</code></pre><p>I needed the key in both targets because the it is accessed by a singleton used by both the app and the widget, and it’s impossible to say which one will get to it first and initialize it. This duplication is annoying, but there is no straightforward way to avoid it so I decided to live with it.</p><h2>Configuring the key in the Github action</h2><p>Finally, I added the key to the repository as a secret, and a step to the Github Action to generate <code>Config.xcconfig</code> before building:</p><pre><code> - name: Create Config.xcconfig
    run: |
      echo "HSL_API_KEY = ${{ secrets.HSL_API_KEY }}" &gt; HslWidget/Config.xcconfig
</code></pre><p>After pushing to main I could see that everything worked properly and I could now retire my compromised key and update the workflow with a new one!</p>
    </div>
</article>
    </main>
    <footer>
        <p>&copy; 2025 Francesco Balestrieri - <a href="/about/">Credits</a></p>
    </footer>
    </div>
  </body>
</html>
